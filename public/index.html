<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #fff;
            width: 100%;
            height: 100%;
        }
        
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            padding: 0;
        }

        canvas {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <script>
    class MainScene extends Phaser.Scene {
        preload() {
            // Load card textures for both decks
            this.load.image('number-card', '/assets/cards/number-card-back.jpeg');
            this.load.image('assist-card', '/assets/cards/assist-card-back.jpeg');
            
            // Create green tile programmatically
            const graphics = this.make.graphics();
            graphics.fillStyle(0x00ff00, 1);
            graphics.fillRect(0, 0, 100, 100);
            graphics.generateTexture('tile', 100, 100);
            graphics.destroy();

            // Create white card front
            const cardFront = this.make.graphics();
            cardFront.fillStyle(0xffffff, 1);
            cardFront.fillRect(0, 0, 100, 140);
            cardFront.lineStyle(2, 0x000000);
            cardFront.strokeRect(0, 0, 100, 140);
            cardFront.generateTexture('card-front', 100, 140);
            cardFront.destroy();
        }

        create() {
            // Game dimensions
            const gameWidth = this.scale.width;
            const gameHeight = this.scale.height;
            
            // Make tiles smaller - use 12% of screen height for better proportions
            const tileSize = Math.min(gameWidth, gameHeight) * 0.12;
            // Calculate spacing between tiles (15% of tile size for tighter grid)
            const tileSpacing = tileSize * 0.15;
            
            // Calculate exact center of the game
            const centerX = gameWidth / 2;
            const centerY = gameHeight / 2;
            
            // Calculate grid dimensions
            const gridWidth = (tileSize * 3) + (tileSpacing * 2);
            const gridHeight = (tileSize * 3) + (tileSpacing * 2);
            
            // Calculate top-left corner of the grid to ensure perfect centering
            const gridStartX = centerX - (gridWidth / 2);
            const gridStartY = centerY - (gridHeight / 2);

            // Create card hand area (placeholder for drawn cards)
            const handAreaHeight = 150;
            const handAreaWidth = gameWidth * 0.6;
            const handArea = this.add.rectangle(
                centerX,
                gameHeight - (handAreaHeight / 2),
                handAreaWidth,
                handAreaHeight,
                0xf0f0f0
            )
            .setStrokeStyle(2, 0x000000)
            .setAlpha(0.5);

            // Add text label for hand area
            this.add.text(centerX, gameHeight - handAreaHeight - 10, 'Your Hand', {
                fontSize: '20px',
                color: '#000000'
            }).setOrigin(0.5);

            // Initialize hand management
            this.handCards = [];
            this.handArea = {
                x: centerX - (handAreaWidth / 2),
                y: gameHeight - handAreaHeight,
                width: handAreaWidth,
                height: handAreaHeight,
                maxCards: 5,  // Maximum cards in hand
                spacing: 120  // Spacing between cards
            };

            // Define positions for 3x3 grid (excluding center)
            const positions = [
                // Top row
                { x: gridStartX, y: gridStartY },
                { x: gridStartX + tileSize + tileSpacing, y: gridStartY },
                { x: gridStartX + (tileSize * 2) + (tileSpacing * 2), y: gridStartY },
                
                // Middle row (sides only)
                { x: gridStartX, y: gridStartY + tileSize + tileSpacing },
                { x: gridStartX + (tileSize * 2) + (tileSpacing * 2), y: gridStartY + tileSize + tileSpacing },
                
                // Bottom row
                { x: gridStartX, y: gridStartY + (tileSize * 2) + (tileSpacing * 2) },
                { x: gridStartX + tileSize + tileSpacing, y: gridStartY + (tileSize * 2) + (tileSpacing * 2) },
                { x: gridStartX + (tileSize * 2) + (tileSpacing * 2), y: gridStartY + (tileSize * 2) + (tileSpacing * 2) }
            ];
            
            // Define deck positions relative to grid
            this.deckY = gridStartY + gridHeight + (tileSize * 0.5); // Position below grid
            this.leftDeckX = centerX - (gridWidth * 0.8);
            this.rightDeckX = centerX + (gridWidth * 0.8);

            // Game state
            this.decks = {
                number: this.createDeck('number', [1, 2, 3, 4, 5]),
                assist: this.createDeck('assist', ['A', 'B', 'C'])
            };
            
            // Create 8 tiles with spacing
            positions.forEach(pos => {
                const tile = this.add.image(pos.x + (tileSize/2), pos.y + (tileSize/2), 'tile')
                    .setDisplaySize(tileSize, tileSize)
                    .setTint(0x00ff00)
                    .setAlpha(0.8)
                    .setOrigin(0.5, 0.5);  // Center the tile on its position
                
                // Add click/tap interaction
                tile.setInteractive();
                tile.on('pointerdown', () => {
                    tile.setTint(Phaser.Display.Color.GetRandom(0, 255, 255));
                });
            });

            // Create deck visuals
            this.createDeckVisual(this.leftDeckX, this.deckY, 'Number Deck');
            this.createDeckVisual(this.rightDeckX, this.deckY, 'Assist Deck');

            // Initialize draw pile in center below grid
            this.drawPile = {
                x: centerX,
                y: this.deckY,
                cards: []
            };
        }

        createDeck(type, values) {
            // Create a deck with given values
            return {
                type: type,
                cards: Phaser.Utils.Array.Shuffle([...values, ...values]), // Double values for pairs
                x: type === 'number' ? this.leftDeckX : this.rightDeckX,
                y: this.deckY
            };
        }

        createDeckVisual(x, y, label) {
            const deckType = label.toLowerCase().includes('number') ? 'number-card' : 'assist-card';
            const deck = this.add.image(x, y, deckType)
                .setDisplaySize(100, 140)
                .setInteractive()
                .on('pointerdown', () => this.drawCard(deckType === 'number-card' ? 'number' : 'assist'));
            
            // Add deck label
            this.add.text(x, y + 90, label, { 
                fontSize: '20px', 
                color: '#000',
                align: 'center'
            }).setOrigin(0.5);
        }

        drawCard(deckType) {
            const deck = this.decks[deckType];
            if (deck.cards.length === 0) return;

            // Check if hand is full
            if (this.handCards.length >= this.handArea.maxCards) {
                // Optional: Show message that hand is full
                const warningText = this.add.text(this.scale.width/2, this.scale.height/2, 'Hand is full!', {
                    fontSize: '24px',
                    color: '#ff0000',
                    backgroundColor: '#ffffff',
                    padding: { x: 10, y: 5 }
                }).setOrigin(0.5);
                
                // Remove warning after 1 second
                this.time.delayedCall(1000, () => warningText.destroy());
                return;
            }

            const cardValue = deck.cards.pop();
            const cardImage = deckType === 'number' ? 'number-card' : 'assist-card';
            const card = this.add.image(deck.x, deck.y, cardImage)
                .setDisplaySize(100, 140)
                .setInteractive()
                .setData('value', cardValue)
                .setData('type', deckType);

            // Calculate position in hand
            const cardIndex = this.handCards.length;
            const totalWidth = this.handCards.length * this.handArea.spacing;
            const startX = this.handArea.x + (this.handArea.width - totalWidth) / 2;
            const targetX = startX + (cardIndex * this.handArea.spacing);
            const targetY = this.handArea.y + (this.handArea.height / 2);

            // Create card front (white background) for number cards
            let cardFront = null;
            let cardText = null;
            
            if (deckType === 'number') {
                cardFront = this.add.image(deck.x, deck.y, 'card-front')
                    .setDisplaySize(100, 140)
                    .setVisible(false);
                
                cardText = this.add.text(deck.x, deck.y, cardValue.toString(), {
                    fontSize: '32px',
                    color: '#0000ff',
                    fontWeight: 'bold'
                })
                .setOrigin(0.5)
                .setVisible(false);
                
                // Flip animation for number cards with movement to hand
                this.tweens.add({
                    targets: card,
                    scaleX: 0,
                    duration: 150,
                    ease: 'Linear',
                    onComplete: () => {
                        card.setVisible(false);
                        cardFront.setVisible(true);
                        cardText.setVisible(true);
                        // Move to hand position
                        this.tweens.add({
                            targets: [cardFront, cardText],
                            x: targetX,
                            y: targetY,
                            scaleX: 1,
                            duration: 300,
                            ease: 'Power2'
                        });
                    }
                });
            } else {
                // For assist cards, just show the value and move to hand
                cardText = this.add.text(deck.x, deck.y, cardValue.toString(), {
                    fontSize: '24px',
                    color: '#ff0000',
                    fontWeight: 'bold'
                }).setOrigin(0.5);

                this.tweens.add({
                    targets: [card, cardText],
                    x: targetX,
                    y: targetY,
                    duration: 300,
                    ease: 'Power2'
                });
            }

            // Enable dragging
            if (deckType === 'number') {
                this.input.setDraggable(cardFront);
                cardFront.setData('text', cardText);
                this.handCards.push(cardFront);
            } else {
                this.input.setDraggable(card);
                this.handCards.push(card);
            }

            // Update drag handling
            this.input.on('dragend', (pointer, gameObject) => {
                gameObject.clearTint();
                // Check if dropped on a grid tile
                const targetTile = this.findTileAtPosition(gameObject.x, gameObject.y);
                if (targetTile) {
                    // Handle card effect on tile
                    targetTile.setTint(Phaser.Display.Color.GetRandom(0, 255, 255));
                    if (gameObject.getData('text')) {
                        gameObject.getData('text').destroy();
                    }
                    // Remove card from hand array
                    const index = this.handCards.indexOf(gameObject);
                    if (index > -1) {
                        this.handCards.splice(index, 1);
                    }
                    gameObject.destroy();
                    // Rearrange remaining cards
                    this.rearrangeHand();
                } else {
                    // Return to hand position
                    const index = this.handCards.indexOf(gameObject);
                    const totalWidth = this.handCards.length * this.handArea.spacing;
                    const startX = this.handArea.x + (this.handArea.width - totalWidth) / 2;
                    const returnX = startX + (index * this.handArea.spacing);
                    
                    this.tweens.add({
                        targets: gameObject,
                        x: returnX,
                        y: this.handArea.y + (this.handArea.height / 2),
                        duration: 200,
                        ease: 'Power2'
                    });

                    if (gameObject.getData('text')) {
                        this.tweens.add({
                            targets: gameObject.getData('text'),
                            x: returnX,
                            y: this.handArea.y + (this.handArea.height / 2),
                            duration: 200,
                            ease: 'Power2'
                        });
                    }
                }
            });
        }

        rearrangeHand() {
            const totalWidth = this.handCards.length * this.handArea.spacing;
            const startX = this.handArea.x + (this.handArea.width - totalWidth) / 2;
            
            this.handCards.forEach((card, index) => {
                const targetX = startX + (index * this.handArea.spacing);
                
                this.tweens.add({
                    targets: card,
                    x: targetX,
                    duration: 200,
                    ease: 'Power2'
                });

                if (card.getData('text')) {
                    this.tweens.add({
                        targets: card.getData('text'),
                        x: targetX,
                        duration: 200,
                        ease: 'Power2'
                    });
                }
            });
        }

        findTileAtPosition(x, y) {
            // Check if position overlaps with any tile
            return this.children.list.find(child => {
                return child.getBounds().contains(x, y) && child.texture.key === 'tile';
            });
        }
    }

    const config = {
        type: Phaser.AUTO,
        parent: 'game-container',
        scale: {
            mode: Phaser.Scale.FIT,
            autoCenter: Phaser.Scale.CENTER_BOTH,
            width: 800,
            height: 600
        },
        backgroundColor: '#ffffff',
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0 },
                debug: false
            }
        },
        scene: MainScene,
        input: {
            touch: true
        }
    };

    const game = new Phaser.Game(config);

    // Handle window resize
    window.addEventListener('resize', () => {
        game.scale.refresh();
    });
    </script>

</body>
</html>