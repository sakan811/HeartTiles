<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #fff;
            width: 100%;
            height: 100%;
        }
        
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            padding: 0;
        }

        canvas {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <script>
    class MainScene extends Phaser.Scene {
        selectedCard = null;

        preload() {
            // Load card textures for both decks
            this.load.image('number-card', 'assets/number-card-back.jpeg');
            this.load.image('assist-card', 'assets/assist-card-back.jpeg');
            
            // Load all cup colors
            this.load.image('cup-white', 'assets/cup-white.jpeg');
            this.load.image('cup-purple', 'assets/cup-purple.jpg');
            this.load.image('cup-red', 'assets/cup-red.jpg');
            this.load.image('cup-green', 'assets/cup-green.jpg');
            this.load.image('cup-brown', 'assets/cup-brown.jpg');
            
            // Create white card front
            const cardFront = this.make.graphics();
            cardFront.fillStyle(0xffffff, 1);
            cardFront.fillRect(0, 0, 100, 140);
            cardFront.lineStyle(2, 0x000000);
            cardFront.strokeRect(0, 0, 100, 140);
            cardFront.generateTexture('card-front', 100, 140);
            cardFront.destroy();
        }

        create() {
            // Game dimensions
            const gameWidth = this.scale.width;
            const gameHeight = this.scale.height;
            
            // Make tiles smaller - use 12% of screen height for better proportions
            const tileSize = Math.min(gameWidth, gameHeight) * 0.12;
            // Calculate spacing between tiles (15% of tile size for tighter grid)
            const tileSpacing = tileSize * 0.15;
            
            // Calculate exact center of the game
            const centerX = gameWidth / 2;
            const centerY = gameHeight / 2;
            
            // Calculate grid dimensions
            const gridWidth = (tileSize * 3) + (tileSpacing * 2);
            const gridHeight = (tileSize * 3) + (tileSpacing * 2);
            
            // Calculate top-left corner of the grid to ensure perfect centering
            const gridStartX = centerX - (gridWidth / 2);
            const gridStartY = centerY - (gridHeight / 2);

            // Create card hand area (placeholder for drawn cards)
            const handAreaHeight = 150;
            const handAreaWidth = gameWidth * 0.6;
            const handArea = this.add.rectangle(
                centerX,
                gameHeight - (handAreaHeight / 2),
                handAreaWidth,
                handAreaHeight,
                0xf0f0f0
            )
            .setStrokeStyle(2, 0x000000)
            .setAlpha(0.5);

            // Add text label for hand area
            this.add.text(centerX, gameHeight - handAreaHeight - 10, 'Your Hand', {
                fontSize: '20px',
                color: '#000000'
            }).setOrigin(0.5);

            // Initialize hand management
            this.handCards = [];
            this.handArea = {
                x: centerX - (handAreaWidth / 2),
                y: gameHeight - handAreaHeight,
                width: handAreaWidth,
                height: handAreaHeight,
                maxCards: 10,  // Increased to 10 cards
                spacing: handAreaWidth / 10  // Dynamic spacing based on area width
            };

            // Define positions for 3x3 grid (excluding center)
            const positions = [
                // Top row
                { x: gridStartX, y: gridStartY },
                { x: gridStartX + tileSize + tileSpacing, y: gridStartY },
                { x: gridStartX + (tileSize * 2) + (tileSpacing * 2), y: gridStartY },
                
                // Middle row (sides only)
                { x: gridStartX, y: gridStartY + tileSize + tileSpacing },
                { x: gridStartX + (tileSize * 2) + (tileSpacing * 2), y: gridStartY + tileSize + tileSpacing },
                
                // Bottom row
                { x: gridStartX, y: gridStartY + (tileSize * 2) + (tileSpacing * 2) },
                { x: gridStartX + tileSize + tileSpacing, y: gridStartY + (tileSize * 2) + (tileSpacing * 2) },
                { x: gridStartX + (tileSize * 2) + (tileSpacing * 2), y: gridStartY + (tileSize * 2) + (tileSpacing * 2) }
            ];
            
            // Define deck positions relative to grid
            this.deckY = gridStartY + (gridHeight / 2); // Position at the same level as the grid
            this.leftDeckX = centerX - (gridWidth * 0.8);
            this.rightDeckX = centerX + (gridWidth * 0.8);

            // Game state
            this.decks = {
                number: this.createDeck('number', [1, 2, 3, 4, 5]),
                assist: this.createDeck('assist', ['A', 'B', 'C', 'D', 'E'])
            };
            
            // Array of available cup colors (excluding white which is for normal tiles)
            const cupColors = ['cup-purple', 'cup-red', 'cup-green', 'cup-brown'];
            
            // Randomly select 4 colors
            const selectedColors = Phaser.Utils.Array.Shuffle([...cupColors]).slice(0, 4);
            
            // Create array of tile indices and shuffle them
            const tileIndices = Phaser.Utils.Array.Shuffle([0, 1, 2, 3, 4, 5, 6, 7]);
            
            // Create 8 tiles with spacing
            positions.forEach((pos, index) => {
                // Only first 4 indices in shuffled array get colored cups
                const hasCup = tileIndices.indexOf(index) < 4;
                const cupColor = hasCup ? selectedColors[tileIndices.indexOf(index)] : 'cup-white';
                
                const tile = this.add.image(pos.x + (tileSize/2), pos.y + (tileSize/2), cupColor)
                    .setDisplaySize(tileSize, tileSize)
                    .setOrigin(0.5, 0.5)
                    .setInteractive();  // Make tile interactive
                
                // All cups are now playable
                tile.setData('hasCup', true);
                tile.setData('score', 0); // Initialize score

                // Modify interaction handler
                tile.on('pointerdown', () => {
                    if (this.selectedCard) {
                        // Make sure the card is a number card and the tile doesn't already have a number
                        if (this.selectedCard.getData('type') === 'number' && !tile.getData('hasNumber')) {
                            this.applyCardToTile(this.selectedCard, tile);
                            // Clear selection after applying
                            this.selectedCard.clearTint();
                            this.selectedCard = null;
                        }
                    }
                });
            });

            // Create deck visuals
            this.createDeckVisual(this.leftDeckX, this.deckY, 'Number Deck');
            this.createDeckVisual(this.rightDeckX, this.deckY, 'Assist Deck');

            // Initialize draw pile in center below grid
            this.drawPile = {
                x: centerX,
                y: this.deckY,
                cards: []
            };
        }

        createDeck(type, values) {
            // For assist cards, create 2 copies of each value
            const pairs = type === 'assist' ? 2 : 2; // Maintain 2 copies for all decks
            return {
                type: type,
                cards: Phaser.Utils.Array.Shuffle(Array(pairs).fill(values).flat()),
                x: type === 'number' ? this.leftDeckX : this.rightDeckX,
                y: this.deckY
            };
        }

        createDeckVisual(x, y, label) {
            const deckType = label.toLowerCase().includes('number') ? 'number-card' : 'assist-card';
            const deck = this.add.image(x, y, deckType)
                .setDisplaySize(100, 140)
                .setInteractive()
                .on('pointerdown', () => this.drawCard(deckType === 'number-card' ? 'number' : 'assist'));
            
            // Add deck label
            this.add.text(x, y + 90, label, { 
                fontSize: '20px', 
                color: '#000',
                align: 'center'
            }).setOrigin(0.5);
        }

        drawCard(deckType) {
            const deck = this.decks[deckType];
            // Check both deck availability and hand capacity first
            if (deck.cards.length === 0 || this.handCards.length >= this.handArea.maxCards) {
                if (this.handCards.length >= this.handArea.maxCards) {
                    const warningText = this.add.text(this.scale.width/2, this.scale.height/2, 'Hand is full!', {
                        fontSize: '24px',
                        color: '#ff0000',
                        backgroundColor: '#ffffff',
                        padding: { x: 10, y: 5 }
                    }).setOrigin(0.5);
                    
                    this.time.delayedCall(1000, () => warningText.destroy());
                }
                return;
            }

            const cardValue = deck.cards.pop();
            const cardImage = deckType === 'number' ? 'number-card' : 'assist-card';
            const card = this.add.image(deck.x, deck.y, cardImage)
                .setDisplaySize(100, 140)
                .setInteractive()
                .setData('value', cardValue)
                .setData('type', deckType)
                .setDepth(1); // Set initial depth

            // Calculate position in hand
            const cardIndex = this.handCards.length;
            const cardWidth = 100;
            const totalSpacing = this.handArea.width - (this.handArea.maxCards * cardWidth);
            const spacingBetween = totalSpacing / (this.handArea.maxCards - 1);
            const targetX = this.handArea.x + (cardWidth / 2) + (cardIndex * (cardWidth + spacingBetween));
            const targetY = this.handArea.y + (this.handArea.height / 2);

            let cardFront = null;
            let cardText = null;
            
            if (deckType === 'number') {
                const numberColors = {
                    1: { hex: 0x800080, cup: 'cup-purple' },  // Purple
                    2: { hex: 0xFF0000, cup: 'cup-red' },     // Red
                    3: { hex: 0x008000, cup: 'cup-green' },   // Green
                    4: { hex: 0x8B4513, cup: 'cup-brown' },   // Brown
                    5: { hex: 0x8B4513, cup: 'cup-brown' }    // Brown
                };

                const cardFront = this.make.graphics();
                cardFront.fillStyle(numberColors[cardValue].hex || 0x000000, 1);
                cardFront.fillRect(0, 0, 100, 140);
                cardFront.lineStyle(2, 0x000000);
                cardFront.strokeRect(0, 0, 100, 140);
                
                const textureName = `card-front-${cardValue}`;
                cardFront.generateTexture(textureName, 100, 140);
                cardFront.destroy();

                const cardFrontSprite = this.add.image(deck.x, deck.y, textureName)
                    .setDisplaySize(100, 140)
                    .setVisible(false)
                    .setDepth(1); // Set same initial depth
                
                cardText = this.add.text(deck.x, deck.y, cardValue.toString(), {
                    fontSize: '32px',
                    color: '#FFFFFF',
                    fontWeight: 'bold'
                })
                .setOrigin(0.5)
                .setVisible(false)
                .setDepth(2); // Text always on top

                // Store the cup color this card matches with
                cardFrontSprite.setData('matchingCup', numberColors[cardValue].cup);

                this.tweens.add({
                    targets: card,
                    scaleX: 0,
                    duration: 150,
                    ease: 'Linear',
                    onComplete: () => {
                        card.destroy(); // Remove the original card
                        cardFrontSprite.setVisible(true);
                        cardText.setVisible(true);
                        
                        this.tweens.add({
                            targets: [cardFrontSprite, cardText],
                            x: targetX,
                            y: targetY,
                            scaleX: 1,
                            duration: 150,
                            ease: 'Linear'
                        });

                        // Add the FRONT SPRITE to handCards instead of original card
                        this.handCards.push(cardFrontSprite);
                        cardFrontSprite.setInteractive();
                        this.input.setDraggable(cardFrontSprite);
                        
                        // Store references directly on the front sprite
                        cardFrontSprite.setData('text', cardText);
                        cardFrontSprite.setData('type', deckType);
                        cardFrontSprite.setData('value', cardValue);
                        
                        // Add click interaction to the front sprite
                        this.addCardClickInteraction(cardFrontSprite, deckType, cardValue);
                        this.updateCardDepths();
                    }
                });
            } else {
                cardText = this.add.text(deck.x, deck.y, cardValue.toString(), {
                    fontSize: '24px',
                    color: '#ff0000',
                    fontWeight: 'bold'
                })
                .setOrigin(0.5)
                .setDepth(2);

                this.tweens.add({
                    targets: [card, cardText],
                    x: targetX,
                    y: targetY,
                    duration: 300,
                    ease: 'Power2',
                    onComplete: () => {
                        // Add to handCards after animation completes
                        this.handCards.push(card);
                        this.updateCardDepths();
                    }
                });

                this.addCardClickInteraction(card, deckType, cardValue);
            }
        }

        addCardClickInteraction(card, deckType, cardValue) {
            card.on('pointerup', (pointer) => {
                if (pointer.getDistance() < 5) {
                    if (deckType === 'number') {
                        // Toggle card selection
                        if (this.selectedCard === card) {
                            // Deselect
                            this.selectedCard = null;
                            card.clearTint();
                        } else {
                            // Select for placement
                            this.selectedCard = card;
                            card.setTint(0x00ff00); // Green tint indicates selection
                        }
                    }
                    const cardIndex = this.handCards.indexOf(card);
                    if (cardIndex > -1) {
                        // Bring to front by moving to end of array AND updating depth
                        this.handCards.splice(cardIndex, 1);
                        this.handCards.push(card);
                        
                        // Explicitly set depth to highest value
                        const newDepth = this.handCards.length * 10 + 1;
                        card.setDepth(newDepth);
                        if (card.getData('text')) {
                            card.getData('text').setDepth(newDepth + 1);
                        }
                        
                        // For number cards, update front sprite depth
                        if (card.getData('frontSprite')) {
                            card.getData('frontSprite').setDepth(newDepth);
                        }
                        
                        this.updateCardDepths(); // Keep this for overall management
                    }

                    const isLifted = card.getData('isLifted') || false;
                    
                    if (!isLifted) {
                        // Lift the card
                        const frontSprite = card.getData('frontSprite');
                        const text = card.getData('text');
                        
                        this.tweens.add({
                            targets: [card, frontSprite, text],
                            y: this.handArea.y + (this.handArea.height / 2) - 20,
                            duration: 200,
                            ease: 'Power2'
                        });
                        
                        const cardDescription = this.add.text(
                            card.x,
                            this.handArea.y - 50,
                            `Card Type: ${deckType}\nValue: ${cardValue}`,
                            {
                                fontSize: '16px',
                                color: '#000',
                                backgroundColor: '#fff',
                                padding: { x: 10, y: 5 }
                            }
                        )
                        .setOrigin(0.5)
                        .setDepth(100); // Description always on top
                        
                        card.setData('description', cardDescription);
                        card.setData('isLifted', true);
                    } else {
                        // Lower the card
                        const frontSprite = card.getData('frontSprite');
                        const text = card.getData('text');
                        
                        this.tweens.add({
                            targets: [card, frontSprite, text],
                            y: this.handArea.y + (this.handArea.height / 2),
                            duration: 200,
                            ease: 'Power2'
                        });
                        
                        const description = card.getData('description');
                        if (description) {
                            description.destroy();
                        }
                        card.setData('isLifted', false);
                    }
                    
                    this.rearrangeHand();
                }
            });
        }

        updateCardDepths() {
            this.handCards.forEach((card, index) => {
                const baseDepth = (index + 1) * 10;
                card.setDepth(baseDepth);
                
                const text = card.getData('text');
                if (text) {
                    text.setDepth(baseDepth + 1);
                }
            });
        }

        rearrangeHand() {
            const cardWidth = 100;
            const totalSpacing = this.handArea.width - (this.handArea.maxCards * cardWidth);
            const spacingBetween = totalSpacing / (this.handArea.maxCards - 1);
            
            this.handCards.forEach((card, index) => {
                const targetX = this.handArea.x + (cardWidth / 2) + (index * (cardWidth + spacingBetween));
                
                this.tweens.add({
                    targets: card,
                    x: targetX,
                    duration: 200,
                    ease: 'Power2'
                });

                const text = card.getData('text');
                if (text) {
                    this.tweens.add({
                        targets: text,
                        x: targetX,
                        duration: 200,
                        ease: 'Power2'
                    });
                }
            });
        }

        findTileAtPosition(x, y) {
            // Check if position overlaps with any tile
            return this.children.list.find(child => {
                return child.getBounds().contains(x, y) && child.texture.key === 'cup-tile';
            });
        }

        applyCardToTile(card, tile) {
            // Get card value correctly (handle both number and assist cards)
            const cardValue = parseInt(card.getData('value'));
            if (isNaN(cardValue)) return; // Only proceed with valid numbers

            // Get the tile's texture key (cup color)
            const cupColor = tile.texture.key;
            
            // Calculate score based on color matching
            let points = cardValue;
            const cardMatchingCup = card.getData('matchingCup');
            
            if (cupColor === 'cup-white') {
                // White cup always gives normal points
                points = cardValue;
            } else if (cardMatchingCup === cupColor) {
                // Double points for matching colors
                points = cardValue * 2;
            } else {
                // Zero points for wrong color match
                points = 0;
            }

            // Mark the tile as having a number
            tile.setData('hasNumber', true);
            
            // Remove card and its associated text from hand
            const cardIndex = this.handCards.indexOf(card);
            if (cardIndex > -1) {
                this.handCards.splice(cardIndex, 1);
                
                // Clean up card elements
                const cardText = card.getData('text');
                const cardDescription = card.getData('description');
                
                if (cardText?.active) {
                    cardText.destroy();
                }
                if (cardDescription?.active) {
                    cardDescription.destroy();
                }
                if (card.active) {
                    card.destroy();
                }
                
                this.rearrangeHand();
            }

            // Update score with animation
            const currentScore = tile.getData('score') || 0;
            const newScore = currentScore + points;
            tile.setData('score', newScore);

            // Store original scale
            const originalScale = tile.scale;
            
            // Animate score update with proper scale reset
            this.tweens.add({
                targets: tile,
                scaleX: originalScale * 0.9,
                scaleY: originalScale * 0.9,
                duration: 100,
                yoyo: true,
                ease: 'Power2',
                onComplete: () => {
                    tile.setScale(originalScale);
                }
            });

            // Score text handling with proper depth
            if (!tile.getData('scoreText')) {
                const scoreText = this.add.text(
                    tile.x,
                    tile.y - tile.displayHeight/2 - 10,
                    newScore.toString(),
                    {
                        fontSize: '24px',
                        color: '#000000',
                        backgroundColor: '#ffffff',
                        padding: { x: 5, y: 2 }
                    }
                )
                .setOrigin(0.5)
                .setDepth(1000); // Ensure text is on top
                tile.setData('scoreText', scoreText);
            } else {
                tile.getData('scoreText')
                    .setText(newScore.toString())
                    .setDepth(1000); // Maintain depth
            }
        }
    }

    const config = {
        type: Phaser.AUTO,
        parent: 'game-container',
        scale: {
            mode: Phaser.Scale.FIT,
            autoCenter: Phaser.Scale.CENTER_BOTH,
            width: 800,
            height: 600
        },
        backgroundColor: '#ffffff',
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0 },
                debug: false
            }
        },
        scene: MainScene,
        input: {
            touch: true
        }
    };

    const game = new Phaser.Game(config);

    // Handle window resize
    window.addEventListener('resize', () => {
        game.scale.refresh();
    });
    </script>

</body>
</html>